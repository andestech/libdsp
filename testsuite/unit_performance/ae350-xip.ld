/* This file is generated by nds_ldsag (version (2018-06-27) ). */
ENTRY(_start)
SECTIONS
{
	PROVIDE (__executable_start = 0x00000000);
	NDS_SAG_LMA_INIT = 0x00000000 ;
	. = 0x00000000;
	EXEC_BEGIN = .;
	.init 	: { KEEP(*(.init )) }
	EXEC_SIZE = . - EXEC_BEGIN;
	NDS_SAG_LMA_TEXT = 0x00001000 ;
	. = 0x00001000;
	EILM_BEGIN = .;
	PROVIDE (__etext = .);
	PROVIDE (_etext = .);
	PROVIDE (etext = .);
	.nds_init 	: { KEEP(*(.nds_init )) }
	.plt 	: { *(.plt ) }
	.text 	: { *(.text .stub .text.* .gnu.linkonce.t.* ) KEEP(*(.text.*personality* )) *(.gnu.warning ) . = ALIGN(4); }
	.fini 	: { KEEP(*(.fini )) }
	.exec.itable 	: { *(.exec.itable ) }
	PROVIDE (__etext = .);
	PROVIDE (_etext = .);
	PROVIDE (etext = .);
	EILM_SIZE = . - EILM_BEGIN;
	__text_lmastart =  LOADADDR (.nds_init);
	__text_start = ADDR(.nds_init);
	.hash 	: { *(.hash ) }
	.dynsym 	: { *(.dynsym ) }
	.dynstr 	: { *(.dynstr ) }
	.gnu.version 	: { *(.gnu.version ) }
	.gnu.version_d 	: { *(.gnu.version_d ) }
	.gnu.version_r 	: { *(.gnu.version_r ) }
	.rela.init 	: { *(.rela.init ) }
	.rela.text 	: { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.* ) }
	.rela.fini 	: { *(.rela.fini ) }
	.rela.rodata 	: { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.* ) }
	.rela.data.rel.ro 	: { *(.rel.data.rel.ro* ) }
	.rela.data 	: { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.* ) }
	.rela.tdata 	: { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.* ) }
	.rela.tbss 	: { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.* ) }
	.rela.ctors 	: { *(.rela.ctors ) }
	.rela.dtors 	: { *(.rela.dtors ) }
	.rela.dyn 	: { *(rela.dyn ) *(.rela__libc_subfreeres ) *(.rela__libc_atexit ) *(.rela__libc_thread_subfreeres ) *(.rela.init_array ) *(.rela.fini_array ) }
	.rela.got 	: { *(.rela.got ) }
	.rela.sdata 	: { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.* ) }
	.rela.sbss 	: { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.* ) }
	.rela.sdata2 	: { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.* ) }
	.rela.sbss2 	: { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.* ) }
	.rela.bss 	: { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.* ) }
	.rela.plt 	: { *(.rela.plt ) }
    . = 0x00200000;
	EDLM_BEGIN = .;
	.interp 	: { *(.interp ) }
	.rodata 	: { *(.rodata .rodata.* .gnu.linkonce.r.* ) }
	.rodata1 	: { *(.rodata1 ) }
	.sdata2 	: { *(.sdata2 .sdata2.* .gnu.linkonce.s2.* ) }
	.sbss2 	: { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.* ) }
	.eh_frame_hdr 	: { *(.eh_frame_hdr ) }
	. = ALIGN(0x20);
	.eh_frame 	: { KEEP(*(.eh_frame )) }
	.gcc_except_table 	: { KEEP(*(.gcc_except_table )) *(.gcc_except_table.* ) }
	.tdata 	: { *(.tdata .tdata.* .gnu.linkonce.td.* ) }
	. = ALIGN(8);
	PROVIDE (__preinit_array_start = .);
	.preinit_array 	: { KEEP(*(.preinit_array )) }
	PROVIDE (__preinit_array_end = .);
	PROVIDE (__init_array_start = .);
	.init_array 	: { KEEP(*(SORT_BY_INIT_PRIORITY(.init_array.* ))) KEEP(*(.init_array )) }
	PROVIDE (__init_array_end = .);
	PROVIDE (__fini_array_start = .);
	.fini_array 	: { KEEP(*(SORT_BY_INIT_PRIORITY(.fini_array.* ))) KEEP(*(.fini_array )) }
	PROVIDE (__fini_array_end = .);
	.ctors 	: { KEEP(*crtbegin*.o(.ctors)) KEEP(*(EXCLUDE_FILE (*crtend*.o) .ctors)) KEEP(*(SORT(.ctors.* ))) KEEP(*(.ctors )) }
	.dtors 	: { KEEP(*crtbegin*.o(.dtors)) KEEP(*(EXCLUDE_FILE (*crtend*.o) .dtors)) KEEP(*(SORT(.dtors.* ))) KEEP(*(.dtors )) }
	.jcr 	: { KEEP(*(.jcr )) }
	.data.rel.ro 	: { *(.data.rel.ro.local ) *(.data.rel.ro* ) }
	.dynamic 	: { *(.dynamic ) }
	. = ALIGN(8);
	.got 	: { *(.got.plt ) *(.got ) }
	.data 	: { *(.data .data.* .gnu.linkonce.d.* ) KEEP(*(.gnu.linkonce.d.*personality* )) SORT(CONSTRUCTORS) . = ALIGN(8); }
	.data1 	: { *(.data1 ) . = ALIGN(8); }
	. = ALIGN(8);
	PROVIDE (__global_pointer$ = . + 0x800);
	.sdata 	: { *(.srodata.cst16 ) *(.srodata.cst8 ) *(.srodata.cst4 ) *(.srodata.cst2 ) *(.srodata .srodata.* ) *(.sdata .sdata.* .gnu.linkonce.s.* ) }
	.sdata_d 	: { *(.sdata_d .sdata_d.* ) }
	.sdata_w 	: { *(.sdata_w .sdata_w.* ) }
	.sdata_h 	: { *(.sdata_h .sdata_h.* ) }
	.sdata_b 	: { *(.sdata_b .sdata_b.* ) }
	.sdata_f 	: { *(.sdata_f .sdata_f.* ) }
	. = ALIGN(8);
	_edata = .;
	PROVIDE (edata = .);
	__bss_start = .;
	PROVIDE (__sbss_start = .);
	PROVIDE (___sbss_start = .);
	.tbss 	(NOLOAD)	: { *(.tbss .tbss.* .gnu.linkonce.tb.* ) *(.tcommon ) }
	.sbss 	(NOLOAD)	: { *(.dynsbss ) *(.sbss .sbss.* .gnu.linkonce.sb.* ) *(.scommon .scommon.* ) }
	.sbss_f 	(NOLOAD)	: { *(.sbss_f .sbss_f.* ) *(.scommon_f .scommon_f.* ) }
	.sbss_b 	(NOLOAD)	: { *(.sbss_b .sbss_b.* ) *(.scommon_b .scommon_b.* ) . = ALIGN(2); }
	.sbss_h 	(NOLOAD)	: { *(.sbss_h .sbss_h.* ) *(.scommon_h .scommon_h.* ) . = ALIGN(4); }
	.sbss_w 	(NOLOAD)	: { *(.sbss_w .sbss_w.* ) *(.scommon_w .scommon_w.* ) *(.dynsbss ) *(.scommon ) . = ALIGN(8); }
	.sbss_d 	(NOLOAD)	: { *(.sbss_d .sbss_d.* ) *(.scommon_d .scommon_d.* ) }
	.bss 	(NOLOAD)	: { *(.dynbss ) *(.bss .bss.* .gnu.linkonce.b.* ) *(COMMON ) . = ALIGN(8); }
	PROVIDE (__sbss_end = .);
	PROVIDE (___sbss_end = .);
	. = ALIGN(8);
	_end = .;
	PROVIDE (end = .);
	PROVIDE (_stack = 0x00280000);
	EDLM_SIZE = . - EDLM_BEGIN;
	.stab	0 : { *(.stab) }
	.stabstr	0 : { *(.stabstr) }
	.stab.excl	0 : { *(.stab.excl) }
	.stab.exclstr	0 : { *(.stab.exclstr) }
	.stab.index	0 : { *(.stab.index) }
	.stab.indexstr	0 : { *(.stab.indexstr) }
	.comment	0 : { *(.comment) }
	.debug	0 : { *(.debug) }
	.line	0 : { *(.line) }
	.debug_srcinfo	0 : { *(.debug_srcinfo) }
	.debug_sfnames	0 : { *(.debug_sfnames) }
	.debug_aranges	0 : { *(.debug_aranges) }
	.debug_pubnames	0 : { *(.debug_pubnames) }
	.debug_info	0 : { *(.debug_info .gnu.linkonce.wi.*) }
	.debug_abbrev	0 : { *(.debug_abbrev) }
	.debug_line	0 : { *(.debug_line) }
	.debug_frame	0 : { *(.debug_frame) }
	.debug_str	0 : { *(.debug_str) }
	.debug_loc	0 : { *(.debug_loc) }
	.debug_macinfo	0 : { *(.debug_macinfo) }
	.debug_weaknames	0 : { *(.debug_weaknames) }
	.debug_funcnames	0 : { *(.debug_funcnames) }
	.debug_typenames	0 : { *(.debug_typenames) }
	.debug_varnames	0 : { *(.debug_varnames) }
}
ASSERT((DEFINED (_RELAX_END_) ? EXEC_SIZE : 0x0)<= 0x00001000, "EXEC OVERFLOW");
ASSERT((DEFINED (_RELAX_END_) ? EILM_SIZE : 0x0)<= 0x0007F000, "EILM OVERFLOW");
ASSERT((DEFINED (_RELAX_END_) ? EDLM_SIZE : 0x0)<= 0x00080000, "EDLM OVERFLOW");
